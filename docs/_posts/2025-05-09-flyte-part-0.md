---
layout: default
title: "Correcting Playlist Rot with Flyte and Kubernetes"
date: "2025/05/09"
publish: true
---

## The Problem: Playlist Rot

I maintain a pretty large [Tidal](FIXME) playlist. Over time, songs on any streamer become `unavailable` as [licensing changes](FIXME see if there's a blog about this). Often, when a streaming service retires a song, they replace it with a different version of the same song, like a remaster. And sometimes the service has multiple versions of the same song, like the original album release and another copy on a "Best of" compilation. When they retire one version, they still have the other.

Anyways, since I have a large playlist, every week or two another five or ten songs become unplayable, while suitable replacements sit there in the streaming library, waiting to be found and enjoyed.

## The Solution: Kubernetes + Flyte (Obviously)

The simplest solution to this problem is obviously to leverage my existing [home Kubernetes infrastructure](FIXME) to host a [Flyte](FIXME) instance orchestrating a custom, horizontally scalable workflow that scans my playlist for "unavailable" tracks, finds suitable replacements for the missing tracks - where possible - and publishes a new playlist comprised of replacement tracks.

![The Simplest Solution](/assets/img/flyte-simplest-solution.png)

ðŸ‘‰ The simplest solution is usually the best one.  
ðŸ‘‰ Speaking of simplicity, I left Kubernetes out of the diagram, but it's there, you'll see.

### Actually, a semi-manual solution is best

Why create a new, small-ish playlist of replacements instead of just updating the larger playlist with the replacements?

For one thing, the "unavailable" songs have silently (in more ways than one) vanished from my life in a most unauthorized and unannounced fashion. It's great to hear them once again! I didn't even know I was missing them, and having them in a focused playlist of disappeared songs is nice.

Second, putting them in a focused, small playlist allows me to review them manually. I can more easily detect false positives and delete them, and fix my matching algorithm. If I add them to the giant playlist, errors won't stand out very easily.

I can merge the corrections into the main playlist at my leisure. 

ðŸ‘‰ Not every workflow benefits from full, end-to-end automation.  
ðŸ‘‰ Don't automate away the fun!

## What is a playlist, anyways?

Here's a Tidal playlist, in JSON format, simplified by my code to include some human-readable information and the all-important Track Identifier.

It's a list of individual Tracks.

```json
[
  {
    "name": "I'm Bored",
    "artist": "Iggy Pop",
    "album": "New Values",
    "version": null,
    "num": 4,
    "id": 661485,
    "artists": [
      "Iggy Pop"
    ],
    "available": true
  },
  {
    "name": "Fight The Power: Remix 2020",
    "artist": "Public Enemy",
    "album": "Fight The Power: Remix 2020",
    "version": null,
    "num": 1,
    "id": 152663861,
    "artists": [
      "Public Enemy",
      "Nas",
      "Rapsody",
      "Black Thought",
      "Jahi",
      "YG",
      "Questlove"
    ],
    "available": true
  }
]   
```

### What is a Track, anyways?

A Track is a song. A Track, on any music streaming service, has an ID. The ID can be an integer or a string, but it's the only thing you need to play some music on a playback device. As far as your playback devices are concerned, a Playlist is a list of Track IDs and nothing else.

The other fields are useful when you want to find two tracks that are "the same", like when transferring a playlist from one service to a competitor's service, where the IDs will be completely different for each track.

They're also useful when you want to find substitutes for a song that is no longer `available`. Two Tracks with different IDs but identical or very similar values for the other attributes might be `the same song`.

#### Track names are messy

Here are some track names from my playlist.

- Red Right Hand (2011 Remastered Version)
- Tour De France (2009 Remaster)
- Prisencolinensinainciusol (Remastered)
- Paranoimia (feat. Max Headroom) [7\" Mix] [2017 Remaster]

That's four vastly different parenthetical methods denoting "Remastered". When looking for sameness between tracks, we can't just scrub "(Remastered)" from the names to simplify comparisons. And we shouldn't scrub anything without first checking if they're strictly equal.

And that's just the `name` field, the `album` field is just as unstandardized.

### Comparing Tracks

How do you know if two tracks are "the same"?

Start simple and refine as needed.

First, `scrub` both tracks to make valid matches easier to find. 

```python
def scrub(ot: model.Track) -> model.Track:
    """Remove attribute string fragments that inhibit matching, e.g. '(Remastered)'."""
    return model.Track(
        id=ot.id,
        name=ot.name,
        artist=ot.artist,
        album=ot.album.replace(" (Remastered)", ""),
        artists=[],
        available=ot.available,
    )
```

The `artists` field is not very useful. Artists often like to be clever with the characters in their names, or change their names over time. It's easier to just zero out the field than try to sort it and reconcile machine-confusing differences.[^simon-and-garfunkel]

[^simon-and-garfunkel]: Are `Simon` and `Garfunkel` two unique elements in an `artists` list, or is it a single element, `Simon & Garfunkel`? It depends!

We can also do some light scrubbing of the album name to make matches more likely.

Next, we can compute a `score` representing the relative sameness of two tracks.

```python
def score(candidate: model.Track, target: model.Track) -> int:
    """Return a match score representing alikeness of two Tracks. Higher score = more alike."""
    if candidate.name != target.name:
        return 0

    s = 10

    if candidate.artist == target.artist:
        s += 10

    if candidate.album == target.album:
        s += 10

    return s
```

It's all very simple. After reviewing the output we can determine the value of complexifying our scrubber or our scoring. Maybe we keep getting lucky and the tracks that Tidal makes "unavailable" don't need much scrubbing to find a replacement.

## Basic Algorithm

The basic algorithm, then, is pretty simple:

1. Fetch the playlist
2. Iterate each Track (song)
3. If the Track is `available`, continue iterating
4. Otherwise, use the music service's Search API to find Tracks that could be replacements
5. `scrub` the unavailble track, modifying fields to make it easier to match
6. Iterate the replacement candidates, `scrub`bing each one
7. Pass each candidate to the `score` function
8. Sort the candidates by score
9. The candidate with the highest nonzero score is our replacement!

Later, we can manually (aurally?) review the selected replacements and refine the scrubber and scorer to produce better outcomes.

;; FIXME: excalidraw steps 4-9 "finding replacement track"

### What about multiple replacement candidates with the same score?

Moving right along!

ðŸ‘‰ That was a good question, friend!

### Is that Artificial Intelligence (AI)?

Yes. Please [email](mailto:invest@mikepartelow.com) if you'd like to invest.

## Prototype

;; based on tidal-backup
;; flawed: it doesn't run on Kubernetes, much less Flyte
;; it doesn't scale horizontally as the list of "unavailable" tracks grows

## Flyte

;; mention the local dev registry docker json change, with code block
;; functional style requires heavy massaging of the prototype

;; stubbing everything out

;; example code

## Some of the code

;; interesting bits from blog.0

## Next Up

;; what's in blog.1 tag?
